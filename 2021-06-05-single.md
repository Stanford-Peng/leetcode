### Move Zeroes

[leetcode 283](https://leetcode.com/problems/move-zeroes/)

Stan

```
class Solution {
    public void moveZeroes(int[] nums) {
        int length = nums.length;
        int[] copy = Arrays.copyOf(nums,length);
        
        int start = 0;
        int end = length - 1;
        for(int cur : copy){
            if(cur == 0){
                nums[end] = cur;
                end--;
            }else{
                nums[start] = cur;
                start++;
            }
        }
    }
}
```

### [leetcode 566.Reshape the Matrix](https://leetcode.com/problems/reshape-the-matrix/)

Stan

```
class Solution {
    public int[][] matrixReshape(int[][] mat, int r, int c) {
        int m = mat.length;
        int n = mat[0].length;
        
        if(m*n !=  r*c) return mat;
        
        int res[][] =  new int[r][c];
        
        int rIndex = 0;
        int cIndex = 0;
        for(int[] row:mat){
            for(int cur : row){
                res[rIndex][cIndex] = cur;
                // cIndex < (c-1) ? cIndex++ : cIndex = 0;
                if(cIndex < (c-1)){
                    cIndex++;
                }else{
                    cIndex = 0;
                    rIndex++;//change row
                }
                
            }
        }
        return res;
    }
}
```
### [Course Schedule](https://leetcode.com/problems/course-schedule/)
Guang  BFS
```java
class Solution {
    public boolean canFinish(int numCourses, int[][] prerequisites) {
        int[] degree = new int[numCourses];
        List<List<Integer>> list = new ArrayList<>(); 
        for(int i = 0; i < numCourses;i++)
          list.add(new ArrayList<>());
        //先求先决课程的children  
        for(int[] value: prerequisites){
            int child = value[0];
            int parent = value[1]; 
            list.get(parent).add(child);
            degree[child]++;
        } 
        //先把degree 里值为0的课程加去队列
        Queue<Integer> queue = new LinkedList<>();
        for(int i = 0; i < numCourses; i++){
             if(degree[i] == 0)
              queue.offer(i);
        }
        while(!queue.isEmpty()){
            int  parent = queue.poll(); 
            numCourses--; 
            for(int children: list.get(parent)){
                if(--degree[children] == 0) 
                 queue.offer(children);
            }
        }
      return numCourses == 0;
    }
}
```
### [Employee Importance](https://leetcode.com/problems/employee-importance/)
Guang BFS
```java
/*
// Definition for Employee.
class Employee {
    public int id;
    public int importance;
    public List<Integer> subordinates;
};
*/

class Solution {
    Queue<Integer> queue = new LinkedList<>();
    int result = 0;
    public int getImportance(List<Employee> employees, int id) {  
       queueAdd(employees,id);

       while(!queue.isEmpty()){
           int size = queue.size();
           for(int i = 0; i < size;i++){
                int childId = queue.poll();
                queueAdd(employees,childId);
           }
       }

       return result;      
    }   
    public void queueAdd(List<Employee> employees, int id){
        for(Employee e: employees){
            if(e.id == id){
               result += e.importance;
               for(int child: e.subordinates){
                   queue.offer(child);
               } 
            }
       } 
    }

}
```

### [1448. Count Good Nodes in Binary Tree](https://leetcode.com/problems/count-good-nodes-in-binary-tree/)
Kang
```java
class Solution {
    
    int res = 0;
    
    public int goodNodes(TreeNode root) {
        check(root.val, root.left);
        check(root.val, root.right);
        return res+=1;
    }
    
    public void check(int max, TreeNode root){
        if(root == null){
            return;
        }
        if(root.val >= max){
            max = root.val;
            res++;
        }
        check(max, root.left);
        check(max, root.right);
        
    }
}
```

### [897. Increasing Order Search Tree](https://leetcode.com/problems/increasing-order-search-tree/)
Kang
```java
class Solution {
    TreeNode prev=null, head=null;
    public TreeNode increasingBST(TreeNode root) {
        if(root==null) return null;   
        increasingBST(root.left);  
        if(prev!=null) { 
        	root.left=null; // we no  longer needs the left  side of the node, so set it to null
        	prev.right=root; 
        }
        if(head==null) head=root; // record the most left node as it will be our root
        prev=root; //keep track of the prev node
        increasingBST(root.right); 
        return head;
    }
}
```
