### 1. Leetcode605:Can Place Flowers (Easy)
Stan
[Leetcode](https://leetcode.com/problems/can-place-flowers/description/)

```
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int places = 0;
        int length = flowerbed.length;
        for(int i = 0;i < length; i++ ){
            int temp = flowerbed[i];
            if(temp == 0 && (i==0||flowerbed[i-1] == 0) && (i==length -1||flowerbed[i+1] == 0)){
                places ++;
                flowerbed[i] = 1;
            }
        }
        boolean res = false;      
        if(n <= places){
            res = true;
            
        }
        return res;
    }
}
```

Kyle
```
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        for(int i = 0; i < flowerbed.length && n > 0; i++){
            if (flowerbed[i] == 0 
                && (i == 0 || flowerbed[i-1] == 0)
                && (i == flowerbed.length-1 || flowerbed[i+1] == 0)) {
                n--;
                flowerbed[i]++;
            }
        }
        return n == 0;
    }
}
```

### 2. Is Subsequence (Medium)
Stan
[Leetcode](https://leetcode.com/problems/is-subsequence/submissions/)
看不出来为啥要把这题放到贪心下面
```
class Solution {
    public boolean isSubsequence(String s, String t) {
        int length1 = s.length();
        int length2 = t.length();
        
        int sp = 0;
        int tp = 0;
        
        while(tp < length2 && sp < length1){
            if(s.charAt(sp) == t.charAt(tp)){
                sp++;
                
            }
            
            tp++;
        }
        if(sp==(length1)) return true;
        return false;
    }
}

```

Kyle

```
class Solution {
    public boolean isSubsequence(String s, String t) {
        for (int i = 0; i < s.length(); s = s.substring(i+1)){
            if (t.length() < s.length() 
                || !t.contains(String.valueOf(s.charAt(i))))
                return false;
            t = t.substring(t.indexOf(s.charAt(i)) + 1);
        }
        return true;
        
    }
}
```
### 3. Integer Break (Medim)
Guang
[LeetCode](https://leetcode.com/problems/integer-break/description/) <br> 解题思路： 用的数学方法  int b = n % 3;  这时b 只能为 0  1   2 
```
class Solution {
    public int integerBreak(int n) {
     if(n <=3){
         return n -1; 
     }

     int a = n/3;
     int b = n % 3; //b 只能为 0  1   2 
     //b == 1
     if(b == 1){
        return (int)Math.pow(3,a - 1) * 4;
     }else if (b == 2){
        return (int)Math.pow(3,a) * b;
     }else{
        return (int)Math.pow(3,a);
     }

    }
}
```

### 4. Perfect Squares(Medium)
Guang
[LeetCode](https://leetcode.com/problems/perfect-squares/description/)  <br> 解题思路：  dp[i] = Math.min(dp[i], dp[i - j*j] + 1); $j \times j$ 是平方数 j从1开始
```
class Solution {
    public int numSquares(int n) {  
     int[] dp = new int[n + 1];
     //dp[0] = 1; 
     for(int i = 1; i < n + 1; i++){
         dp[i] = i;
         for(int j = 1; i - j * j >= 0; j++){
             dp[i] = Math.min(dp[i], dp[i - j*j] + 1);
         }
     }
     
     return dp[n];
    }
}
```
### 5. 814. Binary Tree Pruning (Medium)
Kang
[Leetcode](https://leetcode.com/problems/binary-tree-pruning/)

```
class Solution {
    public TreeNode pruneTree(TreeNode root) {
        if (root == null) return null;
        root.left = pruneTree(root.left);
        root.right = pruneTree(root.right);
        if (root.left == null && root.right == null && root.val == 0) return null;
        return root;
    }
}
```
### 6. 993. Cousins in Binary Tree (Easy)
Kang
[Leetcode](https://leetcode.com/problems/binary-tree-pruning/)
```

```

