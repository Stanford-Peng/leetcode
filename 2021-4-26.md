### 1. Leetcode605:Can Place Flowers (Easy)
Stan
[Leetcode](https://leetcode.com/problems/can-place-flowers/description/)

```
class Solution {
    public boolean canPlaceFlowers(int[] flowerbed, int n) {
        int places = 0;
        int length = flowerbed.length;
        for(int i = 0;i < length; i++ ){
            int temp = flowerbed[i];
            if(temp == 0 && (i==0||flowerbed[i-1] == 0) && (i==length -1||flowerbed[i+1] == 0)){
                places ++;
                flowerbed[i] = 1;
            }
        }
        boolean res = false;      
        if(n <= places){
            res = true;
            
        }
        return res;
    }
}
```

### 2. Is Subsequence (Medium)
Stan
[Leetcode](https://leetcode.com/problems/is-subsequence/submissions/)
看不出来为啥要把这题放到贪心下面
```
class Solution {
    public boolean isSubsequence(String s, String t) {
        int length1 = s.length();
        int length2 = t.length();
        
        int sp = 0;
        int tp = 0;
        
        while(tp < length2 && sp < length1){
            if(s.charAt(sp) == t.charAt(tp)){
                sp++;
                
            }
            
            tp++;
        }
        if(sp==(length1)) return true;
        return false;
    }
}

```
### 3. Integer Break (Medim)
Guang
[LeetCode](https://leetcode.com/problems/integer-break/description/) <br> 解题思路： 用的数学方法  int b = n % 3;  这时b 只能为 0  1   2 
```
class Solution {
    public int integerBreak(int n) {
     if(n <=3){
         return n -1; 
     }

     int a = n/3;
     int b = n % 3; //b 只能为 0  1   2 
     //b == 1
     if(b == 1){
        return (int)Math.pow(3,a - 1) * 4;
     }else if (b == 2){
        return (int)Math.pow(3,a) * b;
     }else{
        return (int)Math.pow(3,a);
     }

    }
}
```

### 4. Perfect Squares(Medium)
Guang
[LeetCode](https://leetcode.com/problems/perfect-squares/description/)  <br> 解题思路：  dp[i] = Math.min(dp[i], dp[i - j*j] + 1);  j $j\times j$ j 是平方数 j从1开始
```
class Solution {
    public int numSquares(int n) {  
     int[] dp = new int[n + 1];
     //dp[0] = 1; 
     for(int i = 1; i < n + 1; i++){
         dp[i] = i;
         for(int j = 1; i - j * j >= 0; j++){
             dp[i] = Math.min(dp[i], dp[i - j*j] + 1);
         }
     }
     
     return dp[n];
    }
}
```


