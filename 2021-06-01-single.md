### [1413. Minimum Value to Get Positive Step by Step Sum](https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/)
Kang - Arrays
```java
class Solution {
    public int minStartValue(int[] nums) {
        int len = nums.length;
        int running = 0;
        int lowest = 0;
        for (int i = 0; i < len; i++) {
            int cur = nums[i];
            running += nums[i];
            lowest = Math.min(lowest, running);
        }
        return Math.abs(lowest)+1;
    }
}

```

### [1260. Shift 2D Grid](https://leetcode.com/problems/shift-2d-grid/)
Kang - Arrays
```java
class Solution {
    public List<List<Integer>> shiftGrid(int[][] grid, int k) {
        int mlen = grid.length;
        int nlen = grid[0].length;
        while(k > 0){
            int[][] gridHolder = new int[mlen][nlen];
            for (int i = 0; i < mlen; i++) {
                for (int j = 0; j < nlen; j++) {
                    int cur = grid[i][j];
                    //if last
                    if(i == mlen - 1 && j == nlen - 1){
                        gridHolder[0][0] = cur;
                    }
                    //else if last j
                    else if(j == nlen-1){
                        gridHolder[i+1][0] = cur;
                    }
                    //else j += 1
                    else{
                        gridHolder[i][j+1] = cur;
                    }
                }
            }
            grid = gridHolder;
            k--;
        }
        List<List<Integer>> list = new ArrayList<>();
        for (int i = 0; i < mlen; i++) {
            List<Integer> l = new ArrayList<>(mlen);
            for (int j = 0; j < nlen; j++) {
                l.add(grid[i][j]);
            }
            list.add(l);
        }
        return list;
    }
}

```
### [Shortest Path in Binary Matrix(Medium)](https://leetcode.com/problems/shortest-path-in-binary-matrix/)
Guang 
```java
class Solution {
    public int shortestPathBinaryMatrix(int[][] grid) {
       if(grid == null || grid.length == 0 || grid[0].length == 0 || grid[0][0] == 1){
            return -1;
       }
       int row = grid.length, col = grid[0].length;
       if(row == 1 &&  grid[0][0] == 0) {
           return 1;
       }
       if(grid[row - 1][col - 1] == 1){
           return - 1;
       }
       Queue<Integer> queue = new LinkedList<>();
       int[] x = {-1,-1,-1,0,0,1,1,1};
       int[] y = {-1,0,1,-1,1,-1,0,1}; 
       queue.add(0);
       int answer = 1;
       while(!queue.isEmpty()){
          int size = queue.size();
          for(int i = 0; i < size;i++){
               int value = queue.poll();
               int valueX =  value / row;
               int valueY = value % row;
               grid[valueX][valueY] = 1;
               for(int z = 0; z < 8; z++){
                   int newX = valueX + x[z];
                   int newY = valueY + y[z];
                   if((newX >= 0 && newX < row)&&(newY >= 0 && newY < col) && grid[newX][newY] == 0){
                       queue.add(newX * row + newY);
                       grid[newX][newY] = 1; 
                   }
                   if(newX == row - 1 && newY == col - 1){
                      return answer + 1;
                   }
               }  
          }  
          answer++; 

       }

      return -1; 
    }
}

```
### Perfect Squares (Medium)
Guang BFS
```java
class Solution {
    public int numSquares(int n) {  
      List<Long> squaresList = generateSquares((long)n);
      Queue<Long> queue = new LinkedList<>(); 
      boolean[] marked = new boolean[n + 1]; 
      queue.add((long)n);
      marked[n] = true; 
      int num = 0; 
      while(!queue.isEmpty()){
        int size = queue.size(); 
        num++; 
        for(int i = 0; i < size; i++){
           long current = queue.poll(); 
           for(long value: squaresList){
               long next = current - value;
               if(next < 0){
                   break;
               }else if(next == 0){
                 //answer
                 return num;
               }
               if(marked[(int)next]){
                   continue; 
               }
               marked[(int)next] = true;
               queue.add(next);
           }  

        }

      }  

     return n;
    }

    public List<Long> generateSquares(Long n){
         List<Long> squares = new ArrayList<>();
         long value = 1;
         while(value * value <= n){
             squares.add(value * value);
             value++;  
         } 

         return squares; 
    }
}
```
### Add Binary

Stan

[leetcode 67](https://leetcode.com/problems/add-binary/)

```
class Solution {
    public String addBinary(String a, String b) {
        int i = 0;
        StringBuffer sb = new StringBuffer();
        int carry = 0;
        int aLen = a.length();
        int bLen = b.length();
        while( i < a.length() || i < b.length()){
            int aBit = i < aLen ? a.charAt(aLen-i-1) - '0' : 0;
            int bBit = i < bLen ? b.charAt(bLen-i-1) - '0' : 0;
            int sum = aBit + bBit + carry;
            int bit = sum % 2;
            carry = sum / 2;
            sb.insert(0,bit);
            i++;
        }
        if(carry != 0) sb.insert(0,carry);
        return sb.toString();
    }
}
```
