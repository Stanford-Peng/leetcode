### 1. [不同的子序列](https://www.lintcode.com/problem/118/ "不同的子序列")

liang

```java
public int numDistinct(String S, String T) {
	if (S == null || T == null) {
		return 0;
	}
	//dp[i][j]表示 S的前i个字符中选取T的前j个字符，有多少种方案
	int[][] dp = new int[S.length() + 1][T.length() + 1];

	//如果Target字符串为空，则无论S当前是什么只要全不取即可，就1种办法
	//如果S字符串为空，则肯定没有方法
	for (int i = 0; i <= S.length(); i++) {
		dp[i][0] = 1;
	}
	for (int j = 1; j <= T.length(); j++) {
		for (int i = 1; i <= S.length(); i++) {
			//不管当前字符是否相等，先将不取i-1位字符的情况加上
			dp[i][j] = dp[i - 1][j];
			if (S.charAt(i - 1) == T.charAt(j - 1)) {
				//当前字符相等，加上取当前第i-1字符的，不取的在之前已经加上了
				dp[i][j] += dp[i - 1][j - 1];
			}
		}
	}
	return dp[S.length()][T.length()];
}
```

------------

### 2. [最小调整代价](https://www.lintcode.com/problem/91/ "最小调整代价")

liang

```java
public int MinAdjustmentCost(List<Integer> A, int target) {
	int n = A.size();
	//        dp[i][j]表示第 i 个数变为 j 的最小代价和，
	//        第i个数可以变成[0..100]内的任何一个数
	//        当第i个数取j的时候，第i-1个数的取值范围是[j-target,j+target] (必须在[0..100]内)
	//        dp[i][j] = min(dp[i][j-target], .... , dp[i][j+tagret]) + abs(A[i] - j)
	int[][] dp = new int[n][101];
	for (int i = 0; i <= 100; i++) {
		dp[0][i] = Math.abs(i-A.get(0));
	}
	for (int i = 1; i < n; i++) {
		for (int j = 0; j <= 100; j++) {
			//这里是为了 求出nums【i】 —> j 的最小代价
			//如果要nums【i】 —> j，那么上一层的范围就只能在 （j-target，t+target）中了，且不能超出（0，100）
			dp[i][j] = Integer.MAX_VALUE;
			int low = Math.max(0,j-target);
			int high = Math.min(100,j+target);
			for (int k = low; k <= high; k++) {
				dp[i][j] = Math.min(dp[i][j],dp[i-1][k]+Math.abs(A.get(i)-j));
			}
		}
	}
	int res = Integer.MAX_VALUE;
	for (int i = 0; i <= 100; i++) {
		res = Math.min(dp[n-1][i],res);
	}
	return res;
}
```
### 3. Palindromic Substrings (Medium)
Guang [LeetCode 647.](https://leetcode.com/problems/palindromic-substrings/description/)
```
class Solution {
    public int countSubstrings(String s) {
        int n = s.length(), ans = 0;
        for (int i = 0; i < 2 * n - 1; ++i) {
            int left = i / 2, right = i / 2 + i % 2;
            while (left >= 0 && right < n && s.charAt(left) == s.charAt(right)) {
                --left;
                ++right;
                ++ans;
            }
        }
        return ans;
    }
}

```
