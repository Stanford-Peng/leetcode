### 1.First Bad Version
Stan

[leetcode 278](https://leetcode.com/problems/first-bad-version/)
```
/* The isBadVersion API is defined in the parent class VersionControl.
      boolean isBadVersion(int version); */

public class Solution extends VersionControl {
    public int firstBadVersion(int n) {
        //binary search
        int left = 1;
        int right = n;
        while(left < right){
            int mid = left + (right - left)/2;
            if(isBadVersion(mid)){
                right = mid;
            }else{
                
                left = mid + 1;
            }
                
        }
        return left;
        
    }
}
```

### 2.Find Minimum in Rotated Sorted Array
Stan

[Leetcode 153](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)

```
class Solution {
    public int findMin(int[] nums) {
        int length = nums.length;
        int left = 0;
        int right = length - 1;
        while(left < right){
            int mid = left + (right - left)/2;
            if(nums[mid] < nums[right]){
                right = mid;
            }else{
                left = mid + 1;
            }
        }
        return nums[left];

    }
}
```
```
class Solution {
    public int findMin(int[] nums) {
        Arrays.sort(nums);
        return nums[0];
    }
}
```

### 3.Find First and Last Position of Element in Sorted Array
Stan

[leetcode 34](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)
```
//two pointers
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int length = nums.length;
        int left = 0;
        int right = length - 1;
        
        while(left <= right){

            if(nums[right]== target && nums[left]==target){
                return new int[]{left,right};
            }
            
            if(nums[left]!=target){
                left++;
            }
            if(nums[right] != target){
                right--;
            }
            
            
        }
        return new int[]{-1,-1};

        
    }
}
```
Follow up: make the complexity : O(log(n))
```
//binary search for twice and searching target + 1 helps find the last target
public int[] searchRange(int[] nums, int target) {
    int first = findFirst(nums, target);
    int last = findFirst(nums, target + 1) - 1;
    if (first == nums.length || nums[first] != target) {
        return new int[]{-1, -1};
    } else {
        return new int[]{first, Math.max(first, last)};
    }
}

private int findFirst(int[] nums, int target) {
    int l = 0, h = nums.length; // 注意 h 的初始值
    while (l < h) {
        int m = l + (h - l) / 2;
        if (nums[m] >= target) {
            h = m;
        } else {
            l = m + 1;
        }
    }
    return l;
}
```
