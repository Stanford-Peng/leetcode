### 1. two Single Number
Stan

[leetcode 260](https://leetcode.com/problems/single-number-iii/)
```
class Solution:
    def singleNumber(self, nums: List[int]) -> List[int]:
        diff = 0
        for i in nums:
            diff ^= i 
        diff &= (-diff) #get the rightest bit 1
        
        res = [0,0]
        for i in nums:
            if(i&diff == 0):
                res[0]^=i
            else:
                res[1]^=i
        ## different nums goes to different positions with pairs of other numbers
        return res
```

### 2. Reverse Bits
Stan
[leetcode 190](https://leetcode.com/problems/reverse-bits/)
```
public class Solution {
    // you need treat n as an unsigned value
    public int reverseBits(int n) {
        int ret = 0;
        for(int i = 0; i<32;i++){
            ret <<= 1;
            ret += (1&n);
            n >>= 1;
        }
        return ret;
    }
}
```
### 3. [分割回文串 II](https://www.lintcode.com/problem/palindrome-partitioning-ii/ "分割回文串 II")

liang

```java
public int minCut(String s) {
        if(s == null || s.length() <= 0){
            return 0;
        }
        char[] str = s.toCharArray();
        int len = s.length();
        boolean[][] ispalindrome = new boolean[len][len];
        //先动态规划求出 所有子区间是否为回文串
        ispalindrome[0][0] = true;
        for (int i = 1; i < len; i++) {
            ispalindrome[i][i] = true;
            if(str[i - 1] == str[i]){
                ispalindrome[i-1][i] = true;
            }
        }
        for (int l = 2; l < len; l++) {
            for (int i = 0; i < len - l; i++) {
                int j = i+l;
                if(str[i] == str[j] && ispalindrome[i+1][j-1]){
                    ispalindrome[i][j] = true;
                }
            }
        }
        int[] dp = new int[len+1];
        for (int i = 0; i <= len; i++) {
            dp[i] = Integer.MAX_VALUE;
        }
        dp[0] = 0;
        //dp[i]代表 字符串前i位内有的最少回文串数
        for (int i = 1; i <= len; i++) {
            for (int j = 0; j < i; j++) {
                if(ispalindrome[j][i-1]){
                    dp[i] = Math.min(dp[i],dp[j]+1);
                }
            }
        }
        return dp[len]-1;
    }
```

------------

### 4. [分割字符串](https://www.lintcode.com/problem/680/ "分割字符串")

liang

```java
public List<List<String>> splitString(String s) {
	List<List<String>> res = new LinkedList<>();
	List<String> list = new LinkedList<>();
	if (s == null){
		return res;
	}
	if(s.length() == 0){
		res.add(list);
		return res;
	}
	dfs(res,list,0,s);
	return res;
}

private void dfs(List<List<String>> res, List<String> list, int index, String s) {
	if(index == s.length()){
		res.add(new LinkedList<>(list));
	}
	for (int i = index+1; i <= index+2 && i <= s.length(); i++) {
		list.add(s.substring(index,i));
		dfs(res,list,i,s);
		list.remove(list.size()-1);
	}
}
```











