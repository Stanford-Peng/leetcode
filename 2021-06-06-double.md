### [leetcode 485. Max Consecutive Ones](https://leetcode.com/problems/max-consecutive-ones/)

Stan

```
    public int findMaxConsecutiveOnes(int[] nums) {
        int cur = 0;
        int max = 0;
        for(int i:nums){
            if(i==1){
                cur++;
            }else{
                max = Math.max(cur,max);
                cur = 0;
            }
        }
        max = Math.max(cur,max);
        return max;
    }
```


### [Leetcode 240. Search a 2D Matrix II](https://leetcode.com/problems/search-a-2d-matrix-ii/)

Stan

```
    public boolean searchMatrix(int[][] matrix, int target) {
    if (matrix == null || matrix.length == 0 || matrix[0].length == 0) return false;
    int m = matrix.length, n = matrix[0].length;
    int row = 0, col = n - 1;
    while (row < m && col >= 0) {
        if (target == matrix[row][col]) return true;
        else if (target < matrix[row][col]) col--;
        else row++;
    }
    return false;
}
```
### 使数组元素相等的减少操作次数
Guang 
```java
class Solution {
    public int reductionOperations(int[] nums) {
        Arrays.sort(nums); 
        int time = 0;      
        List<Integer> list = new ArrayList<>();
        
        for(int i = 1; i < nums.length; i++){
             if(nums[i] == nums[ i - 1]){
                time++;                
             }else{
              list.add(nums[i]); 
               
             }
                 
        }
        if(time == nums.length -1)
            return 0; 
            
       Map<Integer,Integer> map = new HashMap<>();
       for(int i = 0; i < nums.length;i++){
         map.put(nums[i],map.getOrDefault(nums[i],0) + 1);
         
       }
       
       int pre = 0;
       int cur = pre;
       int size = list.size(); 
       for(int i = size - 1; i >= 0;i--){
           pre += map.get(list.get(i));
           cur += pre;
       }
        
       return cur;
     }
}
```
### 判断矩阵经轮转后是否一致
Guang 
```java
class Solution {
    public boolean findRotation(int[][] mat, int[][] target) {
      int row = mat.length;
      
      if(row == 1 ){
         if(mat[0] == target[0])
          return true;
      }
    int time = 0;    
    while(time < 4){
       int count = 0;  
       for(int i = 0; i < row; i++){
       for(int j = 0; j < row;j++){
         if(mat[i][j] != target[i][j]){
            mat = rotate(mat); 
            time++;
            break; 
         }else{
          count++;  
         }            
       }
       if(count / row == row)
          return true;
     }  
        
    } 
     
    return false;
        
    }
    
      public int[][] rotate(int[][] matrix) {
        int n = matrix.length;
        int[][] matrix_new = new int[n][n];
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix_new[j][n - i - 1] = matrix[i][j];
            }
        }
        for (int i = 0; i < n; ++i) {
            for (int j = 0; j < n; ++j) {
                matrix[i][j] = matrix_new[i][j];
            }
        }
      return matrix; 
    }

}
```
