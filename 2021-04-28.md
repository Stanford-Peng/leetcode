### 1. Maximum Length of Pair Chain (Medium)
Guang [LeetCode 646](https://leetcode.com/problems/maximum-length-of-pair-chain/description/) <br/> 解题思路 ：把pairs 里的数对根据第一个数按照从小到达排序，这样的话就和第300题变成一样的题目
```
class Solution {
    public int findLongestChain(int[][] pairs) {
    if(pairs == null )
       return 0;
       int m = pairs.length;
       if(m < 2)
         return m; 
       //pairs 里的数对从小到大排序。 然后 就和300 是一样的题
       Arrays.sort(pairs, (a, b) -> a[0] - b[0]);  
       int[] dp = new int[m];
       Arrays.fill(dp,1);
       for(int i = 1; i < m ;i++){
          for(int j = 0; j < i;j++){
             if(pairs[i][0] > pairs[j][1] )
                dp[i] = Math.max(dp[i], dp[j] + 1);
          }
       }

       int max = 0;
       for(int value : dp){
          max = Math.max(max,value);
       }
       return max;
    }
}
```
### 2. Wiggle Subsequence (Medium)
Guang [Leetcode 376](https://leetcode.com/problems/wiggle-subsequence/description/) <br/> 解题思路：考虑升序和降序结尾的情况。 升序结尾： up = Math.max(up, down + 1); 降序结尾： down = Math.max(down,up + 1); 
```
class Solution {
    public int wiggleMaxLength(int[] nums) {
      int length = nums.length;
      if(length < 2)
         return length; 
      int up = 1,down = 1; 
      for(int i = 1; i < length;i++){
          if(nums[i] > nums[i - 1]) //升序
            up = Math.max(up, down + 1);
          else if(nums[i] < nums[i - 1]) //降序
            down = Math.max(down,up + 1);           
      }
     
      return Math.max(up,down);
    }
}
```
### 3. Longest Common Subsequence
Guang [Leetcode 1143](https://leetcode.com/problems/longest-common-subsequence/) <br/> 解题思路：1. 建立二维矩阵。 2.text1 以i 结尾的char 和 text2以 j 结尾的char，如果相等 则dp[i][j] = dp[i - 1][j - 1] + 1. 否则,dp[i][j] = Math.max(dp[i -1][j],dp[i][j - 1]).
```
class Solution {
    public int longestCommonSubsequence(String text1, String text2) {
      int n = text1.length();
      int m = text2.length();
      int[][] dp = new int[n + 1][m + 1]; 
      for(int i = 1; i < n + 1; i++){
          for(int j = 1; j < m + 1;j++){
             if(text1.charAt(i - 1) == text2.charAt(j - 1)){
                 dp[i][j] = dp[i - 1][j - 1] + 1;
             }else{
                 dp[i][j] = Math.max(dp[i -1][j],dp[i][j - 1]);
             }   

          }
      }

      return dp[n][m];   
    }
}
```

### 4. Invert Binary Tree
Kang [Leetcode](https://leetcode.com/problems/invert-binary-tree/)
```
public TreeNode invertTree(TreeNode root) {
        if(root == null){
            return null;
        }
        
        TreeNode t = root.left;
        root.left = root.right;
        root.right = t;
        
        invertTree(root.left);
        invertTree(root.right);
        
        return root;
    }
```
