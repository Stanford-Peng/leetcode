### 1. Maximum Length of Pair Chain (Medium)
Guang [LeetCode 646](https://leetcode.com/problems/maximum-length-of-pair-chain/description/) <br/> 解题思路 ：把pairs 里的数对根据第一个数按照从小到达排序，这样的话就和第300题变成一样的题目
```
class Solution {
    public int findLongestChain(int[][] pairs) {
    if(pairs == null )
       return 0;
       int m = pairs.length;
       if(m < 2)
         return m; 
       //pairs 里的数对从小到大排序。 然后 就和300 是一样的题
       Arrays.sort(pairs, (a, b) -> a[0] - b[0]);  
       int[] dp = new int[m];
       Arrays.fill(dp,1);
       for(int i = 1; i < m ;i++){
          for(int j = 0; j < i;j++){
             if(pairs[i][0] > pairs[j][1] )
                dp[i] = Math.max(dp[i], dp[j] + 1);
          }
       }

       int max = 0;
       for(int value : dp){
          max = Math.max(max,value);
       }
       return max;
    }
}
```
### 2. Wiggle Subsequence (Medium)
Guang [Leetcode 376](https://leetcode.com/problems/wiggle-subsequence/description/) <br/> 解题思路：考虑升序和降序结尾的情况。 升序结尾： up = Math.max(up, down + 1); 降序结尾： down = Math.max(down,up + 1); 
```
class Solution {
    public int wiggleMaxLength(int[] nums) {
      int length = nums.length;
      if(length < 2)
         return length; 
      int up = 1,down = 1; 
      for(int i = 1; i < length;i++){
          if(nums[i] > nums[i - 1]) //升序
            up = Math.max(up, down + 1);
          else if(nums[i] < nums[i - 1]) //降序
            down = Math.max(down,up + 1);           
      }
     
      return Math.max(up,down);
    }
}
```
