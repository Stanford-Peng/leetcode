### Find Smallest Letter Greater Than Target
Guang
```class Solution {
    public char nextGreatestLetter(char[] letters, char target) {
       int length = letters.length;
       int l = 0, r = length - 1;
       while(l <= r){
           int mid = l + (r - l) / 2;
           if(letters[mid] <= target){
             l = mid + 1;
           }else{
             r = mid - 1;
           }
       }
     
      return l < length ?letters[l] :letters[0];
    }
}
```

### Sqrt(x)
Guang 
```
class Solution {
    public int mySqrt(int x) {
       int l = 1;
       int r = x;
       if(x <= 1){
           return x;
       }

       while(l <= r){
         int mid = l + (r - l) / 2;
         int after = x / mid;
         if(after == mid){
             return mid;
         }else if(after < mid){
            r = mid - 1;
         }else{
            l = mid + 1;
         }
       }
     return r;  
    }
}
```
### Min Stack

Stan

[leetcode 155](https://leetcode.com/problems/min-stack/submissions/)
```
class MinStack {

    private Stack<Integer> dataStack;
    private Stack<Integer> minStack;
    Integer min = Integer.MAX_VALUE;
    /** initialize your data structure here. */
    public MinStack() {
        dataStack = new Stack<>();
        minStack  = new Stack<>();
    }
    
    public void push(int val) {
        dataStack.push(val);//using add leads to same result. Pop actually retrive data from end of the queue
        min = Math.min(val,min);
        minStack.push(min);
    }
    
    public void pop() {
         dataStack.pop();
         minStack.pop();
        min = minStack.isEmpty() ? Integer.MAX_VALUE : minStack.peek();
    }
    
    public int top() {

        return dataStack.peek();
        
    }
    
    public int getMin() {
        return minStack.peek();
    }
}
```
