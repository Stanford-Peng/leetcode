### [蛇梯棋](https://leetcode-cn.com/problems/snakes-and-ladders/)
Guang 
```javascript
/**
 * @param {number[][]} board
 * @return {number}
 */
var snakesAndLadders = function(board) {
      const queue = []
      const size = board.length * board[0].length
      let boardString = []
      boardString.push(0) // boardString.length === size + 1
      let time = 0 
      for(let i = board.length - 1; i >= 0;i--){
          let tt = time % 2
          if(tt === 0){
              for(next of board[i]){
                  boardString.push(next)
              }
          }else{
              let temp1 = board[i].reverse()
              for(next of temp1){
                  boardString.push(next)
              }
           }
          time++ 
      }

      const BFS= (queue,current,boardString) =>{
        for(let i = 1; i < 7 && (i + current) < boardString.length;i++){
            if(boardString[i + current] !== -1){
               queue.push(boardString[current+i])
            }else{
                queue.push(current + i)
            }
        }
      }

      let step = 0
      queue.push(1);
      const set = new Set(); //Store already passed  index      
      while(queue.length){
         const length = queue.length
         for(let i = 0; i < length;i++){
             const current = queue.shift()
             if(current === size){
                return step
             }
             if(!set.has(current)){
                BFS(queue,current,boardString)
                set.add(current)
             }
         }
        step++;
      }

  return -1 
};
```


### [684. Redundant Connection](https://leetcode.com/problems/redundant-connection/submissions/)

Stan

并查集-类似吃鸡跳伞问题 Union Find

```
public int[] findRedundantConnection(int[][] edges) {
    int N = edges.length;
    UF uf = new UF(N);
    for (int[] e : edges) {
        int u = e[0], v = e[1];
        if (uf.connect(u, v)) {
            return e;
        }
        uf.union(u, v);
    }
    return new int[]{-1, -1};
}

private class UF {

    private int[] id;

    UF(int N) {
        id = new int[N + 1];
        for (int i = 0; i < id.length; i++) {
            id[i] = i;
        }
    }

    void union(int u, int v) {
        int uID = find(u);
        int vID = find(v);
        if (uID == vID) {
            return;
        }
        for (int i = 0; i < id.length; i++) {
            if (id[i] == uID) {
                id[i] = vID;
            }
        }
    }

    int find(int p) {
        return id[p];
    }

    boolean connect(int u, int v) {
        return find(u) == find(v);
    }
}

```
