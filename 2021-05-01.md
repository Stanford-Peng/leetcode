### 1. Hamming Distance
位运算：n&(-n) 得到 n 的位级表示中最低的那一位 1。-n 得到 n 的反码加 1，也就是 -n=~n+1。例如对于二进制表示 10110100，-n 得到 01001100，相与得到 00000100。

[Leetcode 461](https://leetcode.com/problems/hamming-distance/)
```
class Solution {
    public int hammingDistance(int x, int y) {
        int temp = x^y;
        return Integer.bitCount(temp);
    }
}
```

### 2. 136. Single Number
[leetcode](https://leetcode.com/problems/single-number/)
Kyle

```
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i = 1; i< nums.length; i+=2){
            if (nums[i - 1] != nums[i]) return nums[i-1];
        }
        return nums[nums.length-1];
    }
}
```

```
class Solution {
    public int singleNumber(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            nums[0] = nums[0] ^ nums[i];
        }
        return nums[0];
    }
}
```
### 3. Coin Change (Medium)
Guang [LeetCode 322.](https://leetcode.com/problems/coin-change/description/)
```
class Solution {
    public int coinChange(int[] coins, int amount) {

       int max = Integer.MAX_VALUE;
       int length = coins.length;
       int[][] dp = new int[length + 1][amount + 1];
       //填写第一行
       //没硬币的情况
       for(int i = 1; i < amount + 1; i++){
           dp[0][i] = max;
       }
       //填写后面的行
       //有硬币的情况
       for(int i = 1; i < length + 1;i++){
           int value = coins[i - 1];
         for(int j = 0; j < amount + 1; j++){
             //不考虑当前的硬币
             dp[i][j] = dp[i - 1][j];
             //考虑当前的硬币
             for(int k = 1; k * value <= j;k++){
                 if(dp[i -1][j - k * value] != Integer.MAX_VALUE)
                   dp[i][j] = Math.min(dp[i][j],dp[i-1][j - k * value] + k);
             }

         } 
       } 
      return dp[length][amount] == max ? -1 : dp[length][amount];
    }
}

```
优化以后
```

```

### 4. Single number II
kyle
[leetcode](https://leetcode.com/problems/single-number-ii/)
```
class Solution {
    public int singleNumber(int[] nums) {
        Arrays.sort(nums);
        for(int i = 1; i < nums.length; i+=3){
            if (nums[i] != nums[i-1])
                return nums[i-1];
        }
        return nums[nums.length-1];
    }
}
```
