### [Profitable Schemes](https://leetcode.com/problems/profitable-schemes/)
Guang 
```java
class Solution {
    public int profitableSchemes(int n, int minProfit, int[] group, int[] profit) {

    int[][] dp = new int[n + 1][minProfit + 1];
    for (int i=0;i<=n;i++) {

        dp[i][0] = 1;
    }

    int len = group.length;
    for (int i=1;i<=len;i++) {

        for (int j=n;j>=group[i - 1];j--) {

            for (int k=minProfit;k>=0;k--) {

                dp[j][k] = (dp[j][k] + dp[j - group[i - 1]][Math.max(0, k - profit[i - 1])])
                                                                                 % 1000000007;
            }
        }
    }
    return dp[n][minProfit];
}

}
```
### [Max Area of Island](https://leetcode.com/problems/max-area-of-island/)
Guang  dfs
```java
class Solution {
    public int maxAreaOfIsland(int[][] grid) {
      int m = grid.length;
      int n = grid[0].length;
      int result = 0; 
      for(int i = 0; i < m;i++){
          for(int j = 0; j < n; j++){
              if(grid[i][j] == 1){
                 result = Math.max(dfs(grid,i,j,m,n),result);
              }
          }
      }
     return result; 
    }
     
    public int dfs(int[][] grid, int i, int j, int m, int n){
      if(i < 0 || i >= m || j < 0 || j >= n || grid[i][j] == 0){
          return 0;
      }
      grid[i][j] = 0;
      int num = 1; 
      num += dfs(grid,i + 1,j,m,n);
      num += dfs(grid,i,j + 1, m,n);
      num += dfs(grid,i - 1, j,m,n);
      num += dfs(grid,i,j-1,m,n);

      return num;
    }
}
```

### [394. Decode String](https://leetcode.com/problems/decode-string/)
Kang 
```java
class Solution {
    
    private StringBuilder res = new StringBuilder();
    private char[] chars;
    private int len;
    public String decodeString(String s) {
        
        chars = s.toCharArray();
        len = chars.length;
        
        for(int i = 0 ; i < len ; i++){
            char c = chars[i];
            if(Character.isDigit(c)){
                String digits = "";
                int skipped = 0;
                while(chars[i] != '['){
                    digits += chars[i];
                    i++;
                }
                //parse given string digit to int
                int times = Integer.valueOf(digits);
                i++;
                for(int j = 0 ; j < times ; j++){
                    skipped = findInside(i);
                }
                i+=skipped;
                
            } else if (c == ']'){
                continue;
            } else {
                res.append(c);
                System.out.println(i);
            }
        }
        return res.toString();
    }
    
    public int findInside(int index){
        int skipped = 0;
        for(int i = index ; i < len ; i++){
            char c = chars[i];
            if(Character.isDigit(c)){
                String digits = "";
                while(chars[i] != '['){
                    digits += chars[i];
                    i++;
                    skipped++;
                }
                //parse given string digit to int
                int times = Integer.valueOf(digits);
                i++;
                skipped++;
                int pp = 0 ;
                for(int j = 0 ; j < times ; j++){
                    pp = findInside(i);
                }
                skipped+= pp+1;
                i+= pp;
                
            } else if(c == ']'){
                break;
                
            } else {
                res.append(c);
                skipped++;
            }
        }
        return skipped;
    }
}
```
### [232. Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)
Kang
```java
class MyQueue {
Stack<Integer> stack1;
    Stack<Integer> stack2;
    boolean is1 = true;
    boolean flipped = false;

    /** Initialize your data structure here. */
    public MyQueue() {
        stack1 = new Stack<>();
        stack2 = new Stack<>();
        
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        if(flipped){
            if(is1){
                is1 = false;
                while(!stack1.isEmpty()){
                    stack2.push(stack1.pop());
                }
                flipped = false;
                stack2.push(x);
            } else {
                is1 = true;
                while(!stack2.isEmpty()){
                    stack1.push(stack2.pop());
                }
                flipped = false;
                stack1.push(x);
            }   
        } else {
            if(is1){
                stack1.push(x);
            } else {
                stack2.push(x);
            }
        }
        
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if(flipped){
            if(is1){
                return stack1.pop();
            } else {
                return stack2.pop();
            }
        }
        else if(is1){
            is1 = false;
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
            flipped = true;
            return stack2.pop();
        } else {
            is1 = true;
            while(!stack2.isEmpty()){
                stack1.push(stack2.pop());
            }
            flipped = true;
            return stack1.pop();
        }
    }
    
    /** Get the front element. */
    public int peek() {
        if(flipped){
            if(is1){
                return stack1.peek();
            } else {
                return stack2.peek();
            }
        } else if(is1){
            is1 = false;
            while(!stack1.isEmpty()){
                stack2.push(stack1.pop());
            }
            flipped = true;
            return stack2.peek();
        } else {
            is1 = true;
            while(!stack2.isEmpty()){
                stack1.push(stack2.pop());
            }
            flipped = true;
            return stack1.peek();
        }
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        if(stack1.isEmpty() && stack2.isEmpty()){
            return true;
        } else {
            return false;
        }
        
    }
    
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```
