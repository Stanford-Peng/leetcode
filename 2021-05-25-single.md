### [Unique Binary Search Trees II (Medium)](https://leetcode.com/problems/unique-binary-search-trees-ii/description/)
Guang
```
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
class Solution {
    public List<TreeNode> generateTrees(int n) {
       if( n < 1){
           return new LinkedList<TreeNode>(); 
       } 

       return generateSubtree(1,n); 
    }

    public List<TreeNode> generateSubtree(int l, int r){
        List<TreeNode> trees = new LinkedList<>();
        if(l > r){
          trees.add(null);
          return trees;  
        }
        //root nodes
        for(int i = l; i < r + 1; i++){
          List<TreeNode> leftTree = generateSubtree(l,i - 1);
          List<TreeNode> rightTree = generateSubtree(i + 1, r);
          for(TreeNode right: rightTree){
              for(TreeNode left: leftTree){
                   TreeNode curTree = new TreeNode(i);
                   curTree.left = left;
                   curTree.right = right;
                   trees.add(curTree);
              }
          }


        }
        return trees;
    }
}
```
