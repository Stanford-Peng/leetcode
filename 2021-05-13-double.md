### 1. 字节跳伞跟随问题
并查集算法的简洁，这个解法问题是每次merge后都有个n次循环的sort。应该可以使用hashmap 做并查优化：

```
package com.company;
import java.util.Arrays;
import java.util.Scanner;

public class ByteDance1 {

    static int[] parents;
    //static int[] rank; //height of tree
    static int[] count;
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        int N = in.nextInt();
        int K = in.nextInt();

        parents = new int[N+1];
        //rank = new int[N+1];
        count = new int[N+1];
        //learning union find

        //ini union
        for (int i = 1; i <= N ; i++) {
            parents[i] = i;
            //rank[i] = 1;
            count[i] = 1;
        }

        //read operations
        for (int i = 0; i < K; i++) {
            int player1 = in.nextInt();
            int player2 = in.nextInt();
            merge(player1,player2);
        }

        //calculate team max members
        System.out.println(Arrays.stream(count).max().getAsInt());
        //calculate team numbers
//        int res = 0;
//        for (int i = 1; i <=N; i++) {
//            if(parents[i] == i){
//                //if it is root node, res++
//                res++;
//            }
//        }
//        System.out.println(res);

    }

    //find parent recursively
    static int find(int x)
    {
        if(x == parents[x])
            return x;
        else{
            //compress the route smartly, no need in current context
            parents[x] = find(parents[x]);  //父节点设为根节点
            return parents[x];         //返回父节点
        }
    }

    //merge two set based on height of tree,
    static void merge(int i, int j){
        if(i==j) return;
        int x = find(i), y = find(j);    //先找到两个根节点
        //int y = find(j);
        if(x==y) return;

        if(i==y){
            // change leader within team

            parents[i] = j;
            count[j] = count[i];
            count[i] = 1;

        }else {
            parents[i] = y;
            count[y]+=count[i];
            if(x==i) count[x] = 1;
        }
        for (int k = 1; k < parents.length; k++) {
            find(k);//resort for leader;increase the complexity
        }


    }
  
 ```
