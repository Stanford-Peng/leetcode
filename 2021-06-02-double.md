### 连续的子数组和 
Guang  前缀和 +  HashSet 
```java
class Solution {
    public boolean checkSubarraySum(int[] nums, int k) {
      int length = nums.length;
      int[] sum = new int[length + 1]; 
      for(int i = 1; i <= length; i++){
         sum[i] = sum[i - 1] + nums[i - 1]; 
      }
      Set<Integer> set = new HashSet<>();
      for(int i = 2; i < length + 1; i++){
         set.add(sum[i - 2] % k);
         if(set.contains(sum[i] % k))
           return true;
      }

      return false;
    }
}
```
### 两整数之和
Guang 
```java
class Solution {
    public int getSum(int a, int b) {
       int xor = a ^ b; 
       int and = (a & b) << 1;  
       while(and != 0){
            int temp = xor & and;
            xor = xor ^ and;
            and = temp << 1;
       }  
       return xor;
    }
}
```

### Next Greater Element II
[leetcode 503](https://leetcode.com/problems/next-greater-element-ii/)
循环两次加stack
Stan
```
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        
        int[] res = new int[nums.length];
        Arrays.fill(res,-1);
        stack.push(0);
        
        
        for(int i = 0; i < nums.length;i++){
            int num = nums[i];
            
            while(!stack.isEmpty() && num > nums[stack.peek()]){
                res[stack.pop()] = num;
            }
            
            stack.push(i);
        }
        
        for(int i = 0; i < nums.length;i++){
            int num = nums[i];
            
            while(num > nums[stack.peek()]){
                res[stack.pop()] = num;
            }

        }
        
        return res;
    }
}
```

### Factorial Trailing Zeroes
[leetcode 172](https://leetcode.com/problems/factorial-trailing-zeroes/submissions/)
Stan

```
class Solution {
    public int trailingZeroes(int n) {
        if(n < 5) return 0;
        return factor5(n) + trailingZeroes(n-1);
    }
    
    public int factor5(int n){
        if(n < 5) return 0;
        return (n % 5 == 0 ? 1 + factor5(n/5) : 0);
    }
}
```

### [1315. Sum of Nodes with Even-Valued Grandparent](https://leetcode.com/problems/sum-of-nodes-with-even-valued-grandparent/)
Kang 
```java
class Solution {
    private int sum = 0;
    public int sumEvenGrandparent(TreeNode root) {
        exploreNode(root);
        return sum;
    }
    
    public void exploreNode(TreeNode node){
        if(node == null){
            return;
        }
        if(node.val%2 == 0){
            if(node.left != null){
                if(node.left.left != null){
                    sum += node.left.left.val;
                }
                if(node.left.right != null){
                    sum += node.left.right.val;
                }
            }
            if(node.right != null){
                if(node.right.left != null){
                    sum += node.right.left.val;
                }
                if(node.right.right != null){
                    sum += node.right.right.val;
                }
            }
        }
        exploreNode(node.left);
        exploreNode(node.right);
    }
}
```

### [756. Pyramid Transition Matrix](https://leetcode.com/problems/pyramid-transition-matrix/)
Kang - DFS
```java
class Solution {
    public boolean pyramidTransition(String bottom, List<String> allowed) {
        Map<String, Set<Character>> m = new HashMap<>();
        for (String s : allowed) {
            String pre = s.substring(0, 2);
            m.putIfAbsent(pre, new HashSet<>());
            m.get(pre).add(s.charAt(2));
        }
        return dfs(bottom, "", m, 1);
    }

    boolean dfs(String row, String nextRow, Map<String, Set<Character>> allowed, int i) {
        if (row.length() == 1) return true;
        if (nextRow.length() + 1 == row.length())
            return dfs(nextRow, "", allowed, 1);
        for (Character c : allowed.getOrDefault(row.substring(i - 1, i + 1), new HashSet<>()))
            if (dfs(row, nextRow + c, allowed, i + 1))
                return true;
        return false;
    }
}
```
