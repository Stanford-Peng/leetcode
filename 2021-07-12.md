### [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)
链表时刻记得头插法
Stan

```
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode l1, ListNode l2) {
        ListNode p1 = l1;
        ListNode p2 = l2;
        ListNode dummy = new ListNode(0);
        ListNode head = dummy;
        while(p1 != null || p2 != null){
            if(p1==null){
                head.next = p2;
                p2 = p2.next;
                head = head.next;
                continue;
            }else if(p2==null){
                head.next = p1;
                p1 = p1.next;
                head = head.next;
                continue;
            }
            
            if(p1.val <= p2.val){               
                head.next = p1;
                // p1.next = null;
                p1 = p1.next;
                head = head.next;
            }else{
                head.next = p2;
                p2 = p2.next;
                head = head.next;
            }
        }
        return dummy.next;
        
    }
}
```

### Strobogrammatic Number II[Google]

Given an integer n, return all the strobogrammatic numbers that are of length n. You may return the answer in any order.

A strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).

Example 1:

Input: n = 2
Output: ["11","69","88","96"]
Example 2:

Input: n = 1
Output: ["0","1","8"]

Stan

```
class Solution {
    
    String[] one = new String[]{"0","1","8"};
    String[] two = new String[]{"11","69", "88", "96","00"};
    public List<String> findStrobogrammatic(int n) {

        if(n==1){
            return Arrays.asList(one);
        }
        if(n==2){
            return Arrays.asList("11","69", "88", "96");
        }
        
        int divided = n/2;
        int remainder = n%2;
        List<String> res = new ArrayList<>();
        StringBuffer prefix = new StringBuffer();
        if(remainder == 0){
            //int[] res = new int[Math.pow(4,divided)];

            // for(int i = 0 ; i < divided; i++){
            //     StringBuffer sb = new StringBuffer
            // }
            backtrack(n,divided, res, prefix,false);
            return res;
        }
        backtrack(n,divided, res, prefix,true);
        
        return res;
        
    }
    public void backtrack(int n,int divided, List<String> res, StringBuffer prefix, boolean isOdd){
        if(prefix.length() == n){
            res.add(prefix.toString());
            return;
        }
        if(isOdd && prefix.length() == 2 * divided){
            
            for(String s : one){
                prefix.insert(divided,s.charAt(0));
                backtrack(n, divided,res,prefix,isOdd);
                prefix.deleteCharAt(divided);
            }
            return;   
        }
        
         for(String s : two){
             if(prefix.length()/2 == divided-1 && s.equals("00")){
                 continue;
             }
             prefix.insert(0,s.charAt(0));
             prefix.append(s.charAt(1));
             backtrack(n, divided,res,prefix,isOdd);
             prefix.deleteCharAt(0);
             prefix.deleteCharAt(prefix.length()-1);
         }
    }
}
```
