### 1. 快速排序

定义一个接口：
```
public abstract class Sort<T extends Comparable<T>> {

    public abstract void sort(T[] nums);

    protected boolean less(T v, T w) {
        return v.compareTo(w) < 0;
    }

    protected void swap(T[] a, int i, int j) {
        T t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
}

```
Stan

```
public class QuickSort<T extends Comparable<T>> extends Sort<T> {

    @Override
    public void sort(T[] nums) {
        shuffle(nums);
        sort(nums, 0, nums.length - 1);
    }

    private void sort(T[] nums, int l, int h) {
        if (h <= l)
            return;
        int j = partition(nums, l, h);
        sort(nums, l, j - 1);
        sort(nums, j + 1, h);
    }

    private void shuffle(T[] nums) {
        List<Comparable> list = Arrays.asList(nums);
        Collections.shuffle(list);
        list.toArray(nums);
    }
}

```

### 2. 三项切分
Stan
Java Arrays.sort()实现方法
```
public class ThreeWayQuickSort<T extends Comparable<T>> extends QuickSort<T> {

    @Override
    protected void sort(T[] nums, int l, int h) {
        if (h <= l) {
            return;
        }
        int lt = l, i = l + 1, gt = h;
        T v = nums[l];
        while (i <= gt) {
            int cmp = nums[i].compareTo(v);
            if (cmp < 0) {
                swap(nums, lt++, i++);
            } else if (cmp > 0) {
                swap(nums, i, gt--);
            } else {
                i++;
            }
        }
        sort(nums, l, lt - 1);
        sort(nums, gt + 1, h);
    }
}

```
### [Best Time to Buy and Sell Stock with Transaction Fee (Medium)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/)
Guang 
```
class Solution {
    public int maxProfit(int[] prices, int fee) {
       int length = prices.length;
       int[] dp = new int[2]; 
       dp[0] = 0;//不持有，利润最大化
       dp[1] = -prices[0]; // 持有， 利润最大化
       for(int i = 1; i < length;i++){
           int temp = dp[0];
           dp[0] = Math.max(dp[0],dp[1] + prices[i] - fee);
           dp[1] = Math.max(dp[1],temp - prices[i]);
       }
       return dp[0];
    }
}
```
### [Best Time to Buy and Sell Stock III (Hard)](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/description/)
Guang
```
class Solution {
    public int maxProfit(int[] prices) {
     int length = prices.length;
     if(length < 2){
       return 0;
     }
     int dp1 = 0; //一直没有持有股票,则利润为0; 
     int dp2 = -prices[0]; //持有股票，买入过一笔;
     int dp3 = Integer.MIN_VALUE;//持有股票，买入过一次，卖出过一次;
     int dp4 = Integer.MIN_VALUE;//持有股票，买入过两次，卖出过一次;
     int dp5 = Integer.MIN_VALUE;//持有股票，买入两次，卖出两次;
     
     for(int i = 1; i < length;i++){
        dp2 = Math.max(dp2,dp1 - prices[i]);
        dp3 = Math.max(dp3,dp2 + prices[i]);
        dp4 = Math.max(dp4,dp3 - prices[i]);
        dp5 = Math.max(dp5,dp4 + prices[i]);
     }
    
     return dp5;
    }
}

```
